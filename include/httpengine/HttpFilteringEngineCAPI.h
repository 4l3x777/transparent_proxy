/*
* Copyright ï¿½ 2017 Jesse Nicholson
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

#pragma once

#include "util/cb/EngineCallbackTypes.h"

#ifndef PVOID
typedef void* PVOID;
#endif

#ifdef HTTP_FILTERING_ENGINE_EXPORT
	#ifdef _MSC_VER
		#define HTTP_FILTERING_ENGINE_API __declspec(dllexport)
	#else
		#define HTTP_FILTERING_ENGINE_API __attribute__((visibility("default")))
	#endif // #ifdef _MSC_VER
#else
	#ifdef _MSC_VER
		#define HTTP_FILTERING_ENGINE_API //__declspec(dllimport)
	#else
		#define HTTP_FILTERING_ENGINE_API
	#endif
#endif // #ifdef HTTP_FILTERING_ENGINE_EXPORT

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

	/// <summary>
	/// Creates a new instance of the HttpFilteringEngineCtl class, which manages the operation of
	/// the HTTP Filtering Engine.
	///
	/// It's a little messy having so many defined callbacks required at creation time, but there is
	/// a lot of information that the Engine can report and request, and is also multithreaded in
	/// nearly every aspect. Avoiding incurring the cost of synchronizing callbacks post creation is
	/// the reason for having this design here.
	/// </summary>
	/// <param name="firewallCb">
	/// A pointer to a method that is meant to determine if the supplied absolute binary path points
	/// to a binary that has been approved for internet access. Required.
	/// </param>
	/// <param name="caBundleAbsolutePath">
	/// An optional, but recommended, pointer to a string of the absolute path of a CA bundle to be
	/// used for upstream client contexts for certificate verification. If nullptr is supplied,
	/// caBundleAbsolutePathLength should be set to zero.
	/// </param>
	/// <param name="caBundleAbsolutePathLength">
	/// The length of the previous caBundleAbsolutePath string. Supply zero if nullptr was supplied
	/// to the caBundleAbsolutePath argument.
	/// </param>
	/// <param name="httpListenerPort">
	/// The desired port for the proxy to listen for incoming plain TCP HTTP clients on. Recommended
	/// to supply a value of zero, as it is recommended to allow the OS to select an available port
	/// from the ephimeral port range.
	/// </param>
	/// <param name="httpsListenerPort">
	/// The desired port for the proxy to listen for incoming secure HTTP clients on. Recommended to
	/// supply a value of zero, as it is recommended to allow the OS to select an available port from
	/// the ephimeral port range.
	/// </param>
	/// <param name="numThreads">
	/// The number of thread to be run against the io_service that drives the proxy and all
	/// associated functionality, barring the platform dependent Diverter. If a value of zero is
	/// supplied, the value will be set internally to the number of logical cores on the device. Be
	/// advised that these threads are the same threads that execute the filtering functionality.
	/// </param>
	/// <param name="onMessageBegin">
	/// Called when a new HTTP transaction starts, with, at-minimum headers, complete.
	/// </param>
	/// <param name="onMessageEnd">
	/// Called when a HTTP transaction that was flagged for content inspection has completed.
	/// </param>
	/// <param name="onInfo">
	/// A pointer to a method that can accept string informational data generated by the underlying
	/// Engine. This callback cannot be supplied post-construction.
	/// </param>
	/// <param name="onWarn">
	/// A pointer to a method that can accept string warning data generated by the underlying Engine.
	/// This callback cannot be supplied post-construction.
	/// </param>
	/// <param name="onError">
	/// A pointer to a method that can accept string error data generated by the underlying Engine.
	/// This callback cannot be supplied post-construction.
	/// </param>
	/// <returns>
	/// A valid pointer to the created instance if the call succeeded, nullptr otherwise.
	/// </returns>
	HTTP_FILTERING_ENGINE_API PVOID fe_ctl_create(
		FirewallCheckCallback firewallCb,
		const char* caBundleAbsolutePath,
		uint32_t caBundleAbsolutePathLength,
		uint16_t httpListenerPort,
		uint16_t httpsListenerPort,
		uint32_t numThreads,
		HttpMessageBeginCallback onMessageBegin,
		HttpMessageEndCallback onMessageEnd,
		ReportMessageCallback onInfo,
		ReportMessageCallback onWarn,
		ReportMessageCallback onError
		);

	/// <summary>
	/// Destroys an existing Engine instance. If the Engine is running, it will be correctly shut
	/// down. Regardless of its state, the Engine instance pointed to will be destroyed and the
	/// supplied ptr argument will no longer be valid.
	/// </summary>
	/// <param name="ptr">
	/// A valid pointer to an existing Engine instance.
	/// </param>
	HTTP_FILTERING_ENGINE_API void fe_ctl_destroy(PVOID* ptr);

	/// <summary>
	/// Destroys an existing Engine instance. If the Engine is running, it will be correctly shut
	/// down. Regardless of its state, the Engine instance pointed to will be destroyed and the
	/// supplied ptr argument will no longer be valid. The difference with this version over
	/// the fe_ctl_destroy method is that it does not take a pointer to pointer, so users
	/// have to take care that they don't double free. This is unfortunately required for
	/// using correctly from C++ CLI.
	/// </summary>
	/// <param name="ptr">
	/// A valid pointer to an existing Engine instance.
	/// </param>
	HTTP_FILTERING_ENGINE_API void fe_ctl_destroy_unsafe(PVOID ptr);

	/// <summary>
	/// Begins intercepting and diverting HTTP/S traffic through the Engine.
	/// </summary>
	/// <param name="ptr">
	/// A valid pointer to an existing Engine instance.
	/// </param>
	HTTP_FILTERING_ENGINE_API const bool fe_ctl_start(PVOID ptr);

	/// <summary>
	/// Stops intercepting and diverting HTTP/S traffic through the Engine.
	/// </summary>
	/// <param name="ptr">
	/// A valid pointer to an existing Engine instance.
	/// </param>
	HTTP_FILTERING_ENGINE_API void fe_ctl_stop(PVOID ptr);

	/// <summary>
	/// Checks if the Engine is actively diverting and filtering HTTP/S traffic or not.
	/// </summary>
	/// <param name="ptr">
	/// A valid pointer to an existing Engine instance.
	/// </param>
	/// <returns>
	/// True if the Engine is actively diverting and filtering HTTP/S traffic, false otherwise.
	/// </returns>
	HTTP_FILTERING_ENGINE_API const bool fe_ctl_is_running(PVOID ptr);

	/// <summary>
	/// Gets the port that the Engine is listening on for diverted HTTP connections.
	/// </summary>
	/// <param name="ptr">
	/// A valid pointer to an existing Engine instance.
	/// </param>
	/// <returns>
	/// The port the Engine is listening on for diverted HTTP connections.
	/// </returns>
	HTTP_FILTERING_ENGINE_API uint16_t fe_ctl_get_http_listener_port(PVOID ptr);

	/// <summary>
	/// Gets the port that the Engine is listening on for diverted HTTPS connections.
	/// </summary>
	/// <param name="ptr">
	/// A valid pointer to an existing Engine instance.
	/// </param>
	/// <returns>
	/// The port the Engine is listening on for diverted HTTPS connections
	/// </returns>
	HTTP_FILTERING_ENGINE_API uint16_t fe_ctl_get_https_listener_port(PVOID ptr);

	/// <summary>
	/// Gets the current root CA being used by the Engine, if any, in PEM format. Memory is allocated
	/// inside the function and the corresponding pointer is assigned to the bufferPP parameter. The
	/// user must call free() on the buffer in the event that the bufferSize parameter has a value
	/// greater than zero after the call.
	/// </summary>
	/// <param name="ptr">
	/// A valid pointer to an existing Engine instance.
	/// </param>
	/// <param name="bufferPP">
	/// A pointer to a char pointer to be populated by the operation.
	/// </param>
	/// <param name="bufferSize">
	/// A pointer to a size_t object that will hold the total number of elements in the populated
	/// array.
	/// </param>
	HTTP_FILTERING_ENGINE_API void fe_ctl_get_rootca_pem(PVOID ptr, char** bufferPP, size_t* bufferSize);

#ifdef __cplusplus
};
#endif // __cplusplus